
# "InputObjectTypeDefinition",
# " loc?: ?Location;
#   description?: ?string;
#   name: Name;
#   directives?: ?Array<Directive>;
#   fields: Array<InputValueDefinition>;",
input_object_type_parse_literal = function(from_input) {

}

validate_value_can_be_coerced = function(from_input, to_type, schema_obj) {

  # A value must be provided if the type is non-null.
  if (inherits(to_type, "NonNullType")) {
    if (is.null(from_input)) {
      stop("Expected ", graphql_string(to_type), " found missing value.")
    }

    if (inherits(from_input, "NullValue")) {
      stop("Expected ", graphql_string(to_type), " found null value.")
    }
    return(
      validate_value_can_be_coerced(from_input, to_type$type, schema_obj)
    )
  }
  # if null, then return valid
  if (is.null(from_input) || inherits(from_input, "NullValue")) {
    return(TRUE)
  }

  # // This function only tests literals, and assumes variables will provide
  # // values of the correct type.
  if (inherits(from_input, "Variable")) {
    stop("variables should not be sent here")
  }

  if (inherits(to_type, "ListType")) {
    list_type <- to_type$type

    if (inherits(from_input, "ListValue")) {
      for (from_value in from_input$values) {
        validate_value_can_be_coerced(from_value, list_type, schema_obj)
      }
      return(TRUE)
    }

    # a single item can be given as a list of size one
    return(
      validate_value_can_be_coerced(from_input, list_type, schema_obj)
    )
  }

  to_obj <- schema_obj$get_type(to_type)
  # to_obj %>% str()
  # browser()

  # // Input objects check each defined field and look for undefined fields.
  if (inherits(to_obj, "InputObjectTypeDefinition")) {
    if (!inherits(from_input, "ObjectValue")) {
      stop("Expected ", to_obj$.kind, ", found not an object")
    }

    # validate field names are unique
    validate_input_object_field_uniqueness(from_input, schema_obj)

    # for each field...
    for (from_field in from_input$fields) {
      to_field <- to_obj$.get_field_by_name(from_field$name)

      # ensure matching field exists
      if (is.null(to_field)) {
        stop("In field: ", from_field$name$value, ": unknown field")
      }
    }

    # for "to field", make sure it is valid
    for (to_field in to_obj$fields) {
      from_field <- from_input$.get_field_by_name(to_field$name)
      # ensure field is valid
      validate_value_can_be_coerced(from_field$value, to_field$type, schema_obj)
    }

    return(TRUE)
  }


  ## should always be the case as it only can be fed from the json AST generated by graphql
  # invariant(
  #   type instanceof GraphQLScalarType || type instanceof GraphQLEnumType,
  #   'Must be input type'
  # );
  if (
    !(
      inherits(to_obj, "ScalarTypeDefinition") ||
      inherits(to_obj, "EnumTypeDefinition")
    )
  ) {
    str(to_obj)
    browser()
    stop("Must be input type")
  }

  # from_input %>% str()
  # cat("\n")
  # to_type %>% str()
  #

  # make sure the resulting type can be coerced.  if it produces a NULL value, it can not be coerced
  result <- to_obj$.parse_literal(from_input)
  if (is.null(result)) {
    stop("Expected type ", graphql_string(to_type), ", found ", from_input$.kind)
  }

  return(TRUE)

}
